# 理解Oauth2.0


::: tip 一个需求
目前我们有个客户已经在用A系统，他想要增设一个图书馆管理系统，学生在图书馆管理系统时同样想通过A系统的账号登录，同时将A已有的基本信息（昵称、邮箱、头像等）同步到图书馆管理系统内。
:::


## 传统解决方案

调用A密码登录接口来验证用户登录，并获取用户基本信息。

### 缺陷

* 系统为了后续服务，会保存用户的密码，这样很不安全
* 系统获得了获取用户储存在A的所有资料的权利，用户没办法限制网站获得的权限范围和有效期
* 系统只有修改密码才能收回赋予网站的权利。但这样做，会使得其他所有用户授权的第三方应用程序全部失效。
* 只要有一个第三方应用程序被破解，就会导致用户密码被泄露，以及所有被密码保护的数据泄露。


::: tip OAuth2.0
OAuth 就是为了解决这个问题而诞生
:::


## 什么是OAuth？


OAuth 在 “客户端”与服务提供商之间，设置了一个授权层（authorization layer）。“客户端”不能直接登录“服务提供商”，只能登录授权层，以此将用户与客户端区分开来。“客户端”登陆授权层所用的令牌（token），与用户的密码不同。用户可以在登陆的时候指定授权层令牌的权限范围和有效期。


## OAuth案例

* 微博授权登录
* 微信授权登录
* QQ授权登录


## OAuth特点

* 对于用户:免去了繁琐的注册过程，降低了注册成本，提高了用户体验
* 对于消费方:简化自身会员系统的同时又能够带来更多的用户和流量。
* 对于服务提供者:围绕自身进行开发，增加用户粘性。


## 运行流程


![img.png](/images/img.png)


1. 用户打开客户端以后，客户端要求用户给予授权
2. 用户同意给予客户端授权
3. 客户端使用上一步获取的授权，向认证服务器申请令牌
4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌
5. 客户端使用令牌，向资源服务器申请获取资源


**客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。**


## 客户端的授权模式

OAuth 2.0 定义了四种授权模式：

* 授权码模式（authorization code）
* 简化模式（implicit  grant type）
* 密码模式（resource owner password credentials）
* 客户端模式（client credentials grant）


### 授权码模式

授权模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与“服务提供商”的认证服务器进行互动。

![img.png](/images/authorization-code-flow.png)


1. 用户访问客户端，后者将前者导向认证服务器
2. 用户选择是否给予客户端授权
3. 假设用户给予授权，认证服务器将用户导向客户端事先指定的“重定向URI”（redirection URI），同时附上一个授权码
4. 客户端收到授权码，附上早先的“重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台服务器上完成的，用户不可见。
5. 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）


### 简化模式

简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，因此而得名。所有步骤在浏览器完成，令牌对访问者是可见的，且客户端不需要认证。

![img.png](/images/implict-gryant-type-flow.png)

1. 客户端将用户导向认证服务器
2. 用户决定是否授权于客户端
3. 假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌
4. 浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值
5. 资源服务器返向一个网页，其中包含的代码可以获取Hash值中的令牌
6. 浏览器执行上一步获得的脚本，提取出令牌
7. 浏览器将令牌发给客户端


### 密码模式

密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向“服务提供商”索要授权。

这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。
![img.png](/images/password-flow.png)

1. 用户向客户端提供用户名和密码
2. 客户端将用户名和密码发给认证服务器，向后者请求令牌
3. 认证服务器确认无误后，向客户端提供访问令牌

**注意：整个过程中，客户端不得保存用户的密码**


#### 密码模式安全隐患

恶意应用使用该方式授权，可以导致暴力破解资源提供方的用户账号和密码。

### 客户端模式

客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向“服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求“服务提供商”提供服务，其实不存在授权的问题。

![img_1.png](/images/client-flow.png)

1. 客户端向认证服务器进行身份认证，并要求一个访问令牌
2. 认证服务器确认无误后，向客户端提供访问令牌

## 更新令牌(RefreshToken)

如果用户访问的时候，客户端的“访问令牌”已经过期，则需要使用“更新令牌”申请一个新的访问令牌。


## OAuth2.0 API示例

* 新浪微博：[http://open.weibo.com/wiki/授权机制说明/](http://open.weibo.com/wiki/授权机制说明/)
* 微信：[https://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html](https://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html)

## OAuth2.0 安全提示

### Server（例如：微信）

* 对client_id和回调地址做严格校验
* 获取access token的code仅能使用一次
* 尽量避免直接读取当前用户session进行绑定

### Client（例如：猿力音乐)
* 使用Authorization Code方式进行授权
* 授权过程使用state随机哈希，并在服务端进行判断
* 尽量使用HTTPS保证授权过程的安全性

## 参考资料

理解OAuth 2.0（作者：阮一峰）：[http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
RFC 6749：[http://www.rfcreader.com/#rfc6749](http://www.rfcreader.com/#rfc6749)
OAuth2.0协议标准：[https://oauth.net/2/](https://oauth.net/2/)

## 名词解释

* Third-party application：第三方应用程序，本文中又称"客户端"（client）
* HTTP service：HTTP服务提供商，本文中简称"服务提供商"
* Resource Owner：资源所有者，又称"用户"（user）
* User Agent：用户代理，又指浏览器
* Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器
* Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器

